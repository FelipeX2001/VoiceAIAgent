function e(){return e=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)({}).hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},e.apply(null,arguments)}function t(e){for(var t=window.atob(e),n=t.length,r=new Uint8Array(n),o=0;o<n;o++)r[o]=t.charCodeAt(o);return r.buffer}var n=new Blob(['\n      const TARGET_SAMPLE_RATE = 16000;\n      class RawAudioProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = TARGET_SAMPLE_RATE / 4; // Define the threshold for buffer size to be ~0.25s\n\n          if (globalThis.LibSampleRate && sampleRate !== TARGET_SAMPLE_RATE) {\n            globalThis.LibSampleRate.create(1, sampleRate, TARGET_SAMPLE_RATE).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n        }\n        process(inputs, outputs) {\n          const input = inputs[0]; // Get the first input node\n          if (input.length > 0) {\n            let channelData = input[0]; // Get the first channel\'s data\n\n            // Resample the audio if necessary\n            if (this.resampler) {\n              channelData = this.resampler.full(channelData);\n            }\n\n            // Add channel data to the buffer\n            this.buffer.push(...channelData);\n            // Get max volume \n            let sum = 0.0;\n            for (let i = 0; i < channelData.length; i++) {\n              sum += channelData[i] * channelData[i];\n            }\n            const maxVolume = Math.sqrt(sum / channelData.length);\n            // Check if buffer size has reached or exceeded the threshold\n            if (this.buffer.length >= this.bufferSize) {\n              const float32Array = new Float32Array(this.buffer)\n              let pcm16Array = new Int16Array(float32Array.length);\n\n              // Iterate through the Float32Array and convert each sample to PCM16\n              for (let i = 0; i < float32Array.length; i++) {\n                // Clamp the value to the range [-1, 1]\n                let sample = Math.max(-1, Math.min(1, float32Array[i]));\n            \n                // Scale the sample to the range [-32768, 32767] and store it in the Int16Array\n                pcm16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n              }\n            \n              // Send the buffered data to the main script\n              this.port.postMessage([pcm16Array, maxVolume]);\n            \n              // Clear the buffer after sending\n              this.buffer = [];\n            }\n          }\n          return true; // Continue processing\n        }\n      }\n      registerProcessor("raw-audio-processor", RawAudioProcessor);\n  '],{type:"application/javascript"}),r=URL.createObjectURL(n),o=/*#__PURE__*/function(){function e(e,t,n,r){this.context=void 0,this.analyser=void 0,this.worklet=void 0,this.inputStream=void 0,this.context=e,this.analyser=t,this.worklet=n,this.inputStream=r}return e.create=function(t){try{var n=null,o=null;return Promise.resolve(function(s,i){try{var a=function(){function s(){return Promise.resolve(n.audioWorklet.addModule(r)).then(function(){return Promise.resolve(navigator.mediaDevices.getUserMedia({audio:{sampleRate:{ideal:t},echoCancellation:{ideal:!0}}})).then(function(t){var r=n.createMediaStreamSource(o=t),s=new AudioWorkletNode(n,"raw-audio-processor");return r.connect(a),a.connect(s),new e(n,a,s,o)})})}var i=navigator.mediaDevices.getSupportedConstraints().sampleRate,a=(n=new window.AudioContext(i?{sampleRate:t}:{})).createAnalyser(),u=function(){if(!i)return Promise.resolve(n.audioWorklet.addModule("https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js")).then(function(){})}();return u&&u.then?u.then(s):s()}()}catch(e){return i(e)}return a&&a.then?a.then(void 0,i):a}(0,function(e){var t,r;throw null==(t=o)||t.getTracks().forEach(function(e){return e.stop()}),null==(r=n)||r.close(),e}))}catch(e){return Promise.reject(e)}},e.prototype.close=function(){try{return this.inputStream.getTracks().forEach(function(e){return e.stop()}),Promise.resolve(this.context.close()).then(function(){})}catch(e){return Promise.reject(e)}},e}(),s=new Blob(['\n      class AudioConcatProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffers = []; // Initialize an empty buffer\n          this.cursor = 0;\n          this.currentBuffer = null;\n          this.wasInterrupted = false;\n          this.finished = false;\n\n          this.port.onmessage = ({ data }) => {\n            switch (data.type) {\n              case "buffer":\n                this.wasInterrupted = false;\n                this.buffers.push(new Int16Array(data.buffer));\n                break;\n              case "interrupt":\n                this.wasInterrupted = true;\n                break;\n              case "clearInterrupted":\n                if (this.wasInterrupted) {\n                  this.wasInterrupted = false;\n                  this.buffers = [];\n                  this.currentBuffer = null;\n                }\n            }\n          };\n        }\n        process(_, outputs) {\n          let finished = false;\n          const output = outputs[0][0];\n          for (let i = 0; i < output.length; i++) {\n            if (!this.currentBuffer) {\n              if (this.buffers.length === 0) {\n                finished = true;\n                break;\n              }\n              this.currentBuffer = this.buffers.shift();\n              this.cursor = 0;\n            }\n\n            output[i] = this.currentBuffer[this.cursor] / 32768;\n            this.cursor++;\n\n            if (this.cursor >= this.currentBuffer.length) {\n              this.currentBuffer = null;\n            }\n          }\n\n          if (this.finished !== finished) {\n            this.finished = finished;\n            this.port.postMessage({ type: "process", finished });\n          }\n\n          return true; // Continue processing\n        }\n      }\n\n      registerProcessor("audio-concat-processor", AudioConcatProcessor);\n    '],{type:"application/javascript"}),i=URL.createObjectURL(s),a=/*#__PURE__*/function(){function e(e,t,n,r){this.context=void 0,this.analyser=void 0,this.gain=void 0,this.worklet=void 0,this.context=e,this.analyser=t,this.gain=n,this.worklet=r}return e.create=function(t){try{var n=null;return Promise.resolve(function(r,o){try{var s=(a=(n=new AudioContext({sampleRate:t})).createAnalyser(),(u=n.createGain()).connect(a),a.connect(n.destination),Promise.resolve(n.audioWorklet.addModule(i)).then(function(){var t=new AudioWorkletNode(n,"audio-concat-processor");return t.connect(u),new e(n,a,u,t)}))}catch(e){return o(e)}var a,u;return s&&s.then?s.then(void 0,o):s}(0,function(e){var t;throw null==(t=n)||t.close(),e}))}catch(e){return Promise.reject(e)}},e.prototype.close=function(){try{return Promise.resolve(this.context.close()).then(function(){})}catch(e){return Promise.reject(e)}},e}();function u(e){return!!e.type}var c=/*#__PURE__*/function(){function e(e,t,n){this.socket=void 0,this.conversationId=void 0,this.sampleRate=void 0,this.socket=e,this.conversationId=t,this.sampleRate=n}return e.create=function(t){try{var n=null;return Promise.resolve(function(r,o){try{var s=(c=null!=(i="undefined"!=typeof process?process.env.ELEVENLABS_CONVAI_SERVER_ORIGIN:null)?i:"wss://api.elevenlabs.io",l=null!=(a="undefined"!=typeof process?process.env.ELEVENLABS_CONVAI_SERVER_PATHNAME:null)?a:"/v1/convai/conversation?agent_id=",n=new WebSocket(t.signedUrl?t.signedUrl:c+l+t.agentId),Promise.resolve(new Promise(function(e,t){n.addEventListener("error",t),n.addEventListener("close",t),n.addEventListener("message",function(t){var n=JSON.parse(t.data);u(n)&&("conversation_initiation_metadata"===n.type?e(n.conversation_initiation_metadata_event):console.warn("First received message is not conversation metadata."))},{once:!0})})).then(function(t){var r=t.conversation_id,o=parseInt(t.agent_output_audio_format.replace("pcm_",""));return new e(n,r,o)}))}catch(e){return o(e)}var i,a,c,l;return s&&s.then?s.then(void 0,o):s}(0,function(e){var t;throw null==(t=n)||t.close(),e}))}catch(e){return Promise.reject(e)}},e.prototype.close=function(){this.socket.close()},e}(),l={onConnect:function(){},onDisconnect:function(){},onError:function(){},onDebug:function(){},onMessage:function(){},onStatusChange:function(){},onModeChange:function(){}},h=/*#__PURE__*/function(){function n(e,n,r,o){var s=this,i=this,a=this,c=this;this.options=void 0,this.connection=void 0,this.input=void 0,this.output=void 0,this.lastInterruptTimestamp=0,this.mode="listening",this.status="connecting",this.inputFrequencyData=void 0,this.outputFrequencyData=void 0,this.volume=1,this.endSession=function(){try{return"connected"!==i.status?Promise.resolve():(i.updateStatus("disconnecting"),i.connection.close(),Promise.resolve(i.input.close()).then(function(){return Promise.resolve(i.output.close()).then(function(){i.updateStatus("disconnected")})}))}catch(e){return Promise.reject(e)}},this.updateMode=function(e){e!==s.mode&&(s.mode=e,s.options.onModeChange({mode:e}))},this.updateStatus=function(e){e!==s.status&&(s.status=e,s.options.onStatusChange({status:e}))},this.onEvent=function(e){try{var t=JSON.parse(e.data);if(!u(t))return;switch(t.type){case"interruption":t.interruption_event&&(s.lastInterruptTimestamp=t.interruption_event.event_id),s.fadeOutAudio();break;case"agent_response":s.options.onMessage({source:"ai",message:t.agent_response_event.agent_response});break;case"user_transcript":s.options.onMessage({source:"user",message:t.user_transcription_event.user_transcript});break;case"internal_tentative_agent_response":s.options.onDebug({type:"tentative_agent_response",response:t.tentative_agent_response_internal_event.tentative_agent_response});break;case"audio":s.lastInterruptTimestamp<=t.audio_event.event_id&&(s.addAudioBase64Chunk(t.audio_event.audio_base_64),s.updateMode("speaking"));break;case"ping":s.connection.socket.send(JSON.stringify({type:"pong",event_id:t.ping_event.event_id}));break;default:s.options.onDebug(t)}}catch(t){return void s.onError("Failed to parse event data",{event:e})}},this.onInputWorkletMessage=function(e){var t,n,r=JSON.stringify({user_audio_chunk:(t=e.data[0].buffer,n=new Uint8Array(t),window.btoa(String.fromCharCode.apply(String,n)))});"connected"===s.status&&s.connection.socket.send(r)},this.onOutputWorkletMessage=function(e){var t=e.data;"process"===t.type&&s.updateMode(t.finished?"listening":"speaking")},this.addAudioBase64Chunk=function(e){try{return a.output.gain.gain.value=a.volume,a.output.worklet.port.postMessage({type:"clearInterrupted"}),a.output.worklet.port.postMessage({type:"buffer",buffer:t(e)}),Promise.resolve()}catch(e){return Promise.reject(e)}},this.fadeOutAudio=function(){try{return c.updateMode("listening"),c.output.worklet.port.postMessage({type:"interrupt"}),c.output.gain.gain.exponentialRampToValueAtTime(1e-4,c.output.context.currentTime+2),setTimeout(function(){c.output.gain.gain.value=c.volume,c.output.worklet.port.postMessage({type:"clearInterrupted"})},2e3),Promise.resolve()}catch(e){return Promise.reject(e)}},this.onError=function(e,t){console.error(e,t),s.options.onError(e,t)},this.calculateVolume=function(e){if(0===e.length)return 0;for(var t=0,n=0;n<e.length;n++)t+=e[n]/255;return(t/=e.length)<0?0:t>1?1:t},this.getId=function(){return s.connection.conversationId},this.setVolume=function(e){s.volume=e.volume},this.getInputByteFrequencyData=function(){return null!=s.inputFrequencyData||(s.inputFrequencyData=new Uint8Array(s.input.analyser.frequencyBinCount)),s.input.analyser.getByteFrequencyData(s.inputFrequencyData),s.inputFrequencyData},this.getOutputByteFrequencyData=function(){return null!=s.outputFrequencyData||(s.outputFrequencyData=new Uint8Array(s.output.analyser.frequencyBinCount)),s.output.analyser.getByteFrequencyData(s.outputFrequencyData),s.outputFrequencyData},this.getInputVolume=function(){return s.calculateVolume(s.getInputByteFrequencyData())},this.getOutputVolume=function(){return s.calculateVolume(s.getOutputByteFrequencyData())},this.options=e,this.connection=n,this.input=r,this.output=o,this.options.onConnect({conversationId:n.conversationId}),this.connection.socket.addEventListener("message",function(e){s.onEvent(e)}),this.connection.socket.addEventListener("error",function(e){s.updateStatus("disconnected"),s.onError("Socket error",e)}),this.connection.socket.addEventListener("close",function(){s.updateStatus("disconnected"),s.options.onDisconnect()}),this.input.worklet.port.onmessage=this.onInputWorkletMessage,this.output.worklet.port.onmessage=this.onOutputWorkletMessage,this.updateStatus("connected")}return n.startSession=function(t){try{var r=e({},l,t);r.onStatusChange({status:"connecting"});var s=null,i=null,u=null;return Promise.resolve(function(e,l){try{var h=Promise.resolve(o.create(16e3)).then(function(e){return s=e,Promise.resolve(c.create(t)).then(function(e){return i=e,Promise.resolve(a.create(i.sampleRate)).then(function(e){return new n(r,i,s,u=e)})})})}catch(e){return l(e)}return h&&h.then?h.then(void 0,l):h}(0,function(e){var t,n;return r.onStatusChange({status:"disconnected"}),null==(t=i)||t.close(),Promise.resolve(null==(n=s)?void 0:n.close()).then(function(){var t;return Promise.resolve(null==(t=u)?void 0:t.close()).then(function(){throw e})})}))}catch(e){return Promise.reject(e)}},n}();export{h as Conversation};
//# sourceMappingURL=lib.module.js.map
