{"version":3,"file":"lib.modern.js","sources":["../src/utils/audio.ts","../src/utils/rawAudioProcessor.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.ts","../src/utils/output.ts","../src/utils/events.ts","../src/utils/connection.ts","../src/index.ts"],"sourcesContent":["export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const blob = new Blob(\n  [\n    `\n      const TARGET_SAMPLE_RATE = 16000;\n      class RawAudioProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = TARGET_SAMPLE_RATE / 4; // Define the threshold for buffer size to be ~0.25s\n\n          if (globalThis.LibSampleRate && sampleRate !== TARGET_SAMPLE_RATE) {\n            globalThis.LibSampleRate.create(1, sampleRate, TARGET_SAMPLE_RATE).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n        }\n        process(inputs, outputs) {\n          const input = inputs[0]; // Get the first input node\n          if (input.length > 0) {\n            let channelData = input[0]; // Get the first channel's data\n\n            // Resample the audio if necessary\n            if (this.resampler) {\n              channelData = this.resampler.full(channelData);\n            }\n\n            // Add channel data to the buffer\n            this.buffer.push(...channelData);\n            // Get max volume \n            let sum = 0.0;\n            for (let i = 0; i < channelData.length; i++) {\n              sum += channelData[i] * channelData[i];\n            }\n            const maxVolume = Math.sqrt(sum / channelData.length);\n            // Check if buffer size has reached or exceeded the threshold\n            if (this.buffer.length >= this.bufferSize) {\n              const float32Array = new Float32Array(this.buffer)\n              let pcm16Array = new Int16Array(float32Array.length);\n\n              // Iterate through the Float32Array and convert each sample to PCM16\n              for (let i = 0; i < float32Array.length; i++) {\n                // Clamp the value to the range [-1, 1]\n                let sample = Math.max(-1, Math.min(1, float32Array[i]));\n            \n                // Scale the sample to the range [-32768, 32767] and store it in the Int16Array\n                pcm16Array[i] = sample < 0 ? sample * 32768 : sample * 32767;\n              }\n            \n              // Send the buffered data to the main script\n              this.port.postMessage([pcm16Array, maxVolume]);\n            \n              // Clear the buffer after sending\n              this.buffer = [];\n            }\n          }\n          return true; // Continue processing\n        }\n      }\n      registerProcessor(\"raw-audio-processor\", RawAudioProcessor);\n  `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const rawAudioProcessor = URL.createObjectURL(blob);\n","import { rawAudioProcessor } from \"./rawAudioProcessor\";\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create(sampleRate: number): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await context.audioWorklet.addModule(rawAudioProcessor);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: { ideal: sampleRate },\n          echoCancellation: { ideal: true },\n        },\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n}\n","const blob = new Blob(\n  [\n    `\n      class AudioConcatProcessor extends AudioWorkletProcessor {\n        constructor() {\n          super();\n          this.buffers = []; // Initialize an empty buffer\n          this.cursor = 0;\n          this.currentBuffer = null;\n          this.wasInterrupted = false;\n          this.finished = false;\n\n          this.port.onmessage = ({ data }) => {\n            switch (data.type) {\n              case \"buffer\":\n                this.wasInterrupted = false;\n                this.buffers.push(new Int16Array(data.buffer));\n                break;\n              case \"interrupt\":\n                this.wasInterrupted = true;\n                break;\n              case \"clearInterrupted\":\n                if (this.wasInterrupted) {\n                  this.wasInterrupted = false;\n                  this.buffers = [];\n                  this.currentBuffer = null;\n                }\n            }\n          };\n        }\n        process(_, outputs) {\n          let finished = false;\n          const output = outputs[0][0];\n          for (let i = 0; i < output.length; i++) {\n            if (!this.currentBuffer) {\n              if (this.buffers.length === 0) {\n                finished = true;\n                break;\n              }\n              this.currentBuffer = this.buffers.shift();\n              this.cursor = 0;\n            }\n\n            output[i] = this.currentBuffer[this.cursor] / 32768;\n            this.cursor++;\n\n            if (this.cursor >= this.currentBuffer.length) {\n              this.currentBuffer = null;\n            }\n          }\n\n          if (this.finished !== finished) {\n            this.finished = finished;\n            this.port.postMessage({ type: \"process\", finished });\n          }\n\n          return true; // Continue processing\n        }\n      }\n\n      registerProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n    `,\n  ],\n  { type: \"application/javascript\" }\n);\n\nexport const audioConcatProcessor = URL.createObjectURL(blob);\n","import { audioConcatProcessor } from \"./audioConcatProcessor\";\n\nexport class Output {\n  public static async create(sampleRate: number): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await context.audioWorklet.addModule(audioConcatProcessor);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.connect(gain);\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n","export type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    average_ping_ms?: number;\n  };\n};\n\n// TODO correction missing\nexport type SocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent;\n\nexport function isValidSocketEvent(event: any): event is SocketEvent {\n  return !!event.type;\n}\n","import { ConfigEvent, isValidSocketEvent } from \"./events\";\n\ndeclare const process: {\n  env: {\n    ELEVENLABS_CONVAI_SERVER_ORIGIN?: string;\n    ELEVENLABS_CONVAI_SERVER_PATHNAME?: string;\n  };\n};\n\nexport type SessionConfig =\n  | { signedUrl: string; agentId?: undefined }\n  | { agentId: string; signedUrl?: undefined };\n\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class Connection {\n  public static async create(config: SessionConfig): Promise<Connection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin =\n        (typeof process !== \"undefined\"\n          ? process.env.ELEVENLABS_CONVAI_SERVER_ORIGIN\n          : null) ?? WSS_API_ORIGIN;\n\n      const pathname =\n        (typeof process !== \"undefined\"\n          ? process.env.ELEVENLABS_CONVAI_SERVER_PATHNAME\n          : null) ?? WSS_API_PATHNAME;\n\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + pathname + config.agentId;\n\n      socket = new WebSocket(url);\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\"error\", reject);\n        socket!.addEventListener(\"close\", reject);\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const conversationId = conversationConfig.conversation_id;\n      const sampleRate = parseInt(\n        conversationConfig.agent_output_audio_format.replace(\"pcm_\", \"\")\n      );\n\n      return new Connection(socket, conversationId, sampleRate);\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly socket: WebSocket,\n    public readonly conversationId: string,\n    public readonly sampleRate: number\n  ) {}\n\n  public close() {\n    this.socket.close();\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { Connection, SessionConfig } from \"./utils/connection\";\nimport { isValidSocketEvent, PingEvent } from \"./utils/events\";\n\nexport type { SocketEvent } from \"./utils/events\";\nexport type { SessionConfig } from \"./utils/connection\";\n\nexport type Role = \"user\" | \"ai\";\nexport type Mode = \"speaking\" | \"listening\";\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\nexport type Options = SessionConfig & Callbacks;\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  onDisconnect: () => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onError: (message: string, context?: any) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n};\n\nconst DEFAULT_SAMPLE_RATE = 16000;\n\nconst defaultCallbacks: Callbacks = {\n  onConnect: () => {},\n  onDisconnect: () => {},\n  onError: () => {},\n  onDebug: () => {},\n  onMessage: () => {},\n  onStatusChange: () => {},\n  onModeChange: () => {},\n};\n\nexport class Conversation {\n  public static async startSession(\n    options: SessionConfig & Partial<Callbacks>\n  ): Promise<Conversation> {\n    const fullOptions: Options = {\n      ...defaultCallbacks,\n      ...options,\n    };\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n\n    let input: Input | null = null;\n    let connection: Connection | null = null;\n    let output: Output | null = null;\n\n    try {\n      input = await Input.create(DEFAULT_SAMPLE_RATE);\n      connection = await Connection.create(options);\n      output = await Output.create(connection.sampleRate);\n\n      return new Conversation(fullOptions, connection, input, output);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      throw error;\n    }\n  }\n\n  private lastInterruptTimestamp: number = 0;\n  private mode: Mode = \"listening\";\n  private status: Status = \"connecting\";\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n  private volume: number = 1;\n\n  private constructor(\n    private readonly options: Options,\n    private readonly connection: Connection,\n    public readonly input: Input,\n    public readonly output: Output\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n\n    this.connection.socket.addEventListener(\"message\", event => {\n      this.onEvent(event);\n    });\n    this.connection.socket.addEventListener(\"error\", event => {\n      this.updateStatus(\"disconnected\");\n      this.onError(\"Socket error\", event);\n    });\n    this.connection.socket.addEventListener(\"close\", () => {\n      this.updateStatus(\"disconnected\");\n      this.options.onDisconnect();\n    });\n\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession = async () => {\n    if (this.status !== \"connected\") return;\n    this.updateStatus(\"disconnecting\");\n\n    this.connection.close();\n    await this.input.close();\n    await this.output.close();\n\n    this.updateStatus(\"disconnected\");\n  };\n\n  private updateMode = (mode: Mode) => {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  };\n\n  private updateStatus = (status: Status) => {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  };\n\n  private onEvent = (event: MessageEvent) => {\n    try {\n      const parsedEvent = JSON.parse(event.data);\n\n      if (!isValidSocketEvent(parsedEvent)) {\n        return;\n      }\n\n      switch (parsedEvent.type) {\n        case \"interruption\": {\n          if (parsedEvent.interruption_event) {\n            this.lastInterruptTimestamp =\n              parsedEvent.interruption_event.event_id;\n          }\n          this.fadeOutAudio();\n          break;\n        }\n\n        case \"agent_response\": {\n          this.options.onMessage({\n            source: \"ai\",\n            message: parsedEvent.agent_response_event.agent_response,\n          });\n          break;\n        }\n\n        case \"user_transcript\": {\n          this.options.onMessage({\n            source: \"user\",\n            message: parsedEvent.user_transcription_event.user_transcript,\n          });\n          break;\n        }\n\n        case \"internal_tentative_agent_response\": {\n          this.options.onDebug({\n            type: \"tentative_agent_response\",\n            response:\n              parsedEvent.tentative_agent_response_internal_event\n                .tentative_agent_response,\n          });\n          break;\n        }\n\n        case \"audio\": {\n          if (\n            this.lastInterruptTimestamp <= parsedEvent.audio_event.event_id!\n          ) {\n            this.addAudioBase64Chunk(parsedEvent.audio_event.audio_base_64);\n            this.updateMode(\"speaking\");\n          }\n          break;\n        }\n\n        case \"ping\": {\n          this.connection.socket.send(\n            JSON.stringify({\n              type: \"pong\",\n              event_id: (parsedEvent as PingEvent).ping_event.event_id,\n            })\n          );\n          // parsedEvent.ping_event.average_ping_ms can be used on client side, for\n          // example to warn if ping is too high that experience might be degraded.\n          break;\n        }\n\n        // unhandled events are expected to be internal events\n        default: {\n          this.options.onDebug(parsedEvent);\n          break;\n        }\n      }\n    } catch {\n      this.onError(\"Failed to parse event data\", { event });\n      return;\n    }\n  };\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n    const maxVolume = event.data[1];\n\n    // check if the sound was loud enough, so we don't send unnecessary chunks\n    // then forward audio to websocket\n    //if (maxVolume > 0.001) {\n    const audioMessage = JSON.stringify({\n      user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n      //sample_rate: this.inputAudioContext?.inputSampleRate || this.inputSampleRate,\n    });\n    if (this.status === \"connected\") {\n      this.connection.socket.send(audioMessage);\n    }\n    //}\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = async (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = async () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private onError = (message: string, context?: any) => {\n    console.error(message, context);\n    this.options.onError(message, context);\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public getId = () => this.connection.conversationId;\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public getInputByteFrequencyData = () => {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  };\n\n  public getOutputByteFrequencyData = () => {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  };\n\n  public getInputVolume = () => {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  };\n\n  public getOutputVolume = () => {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  };\n}\n"],"names":["arrayBufferToBase64","b","buffer","Uint8Array","window","btoa","String","fromCharCode","base64ToArrayBuffer","base64","binaryString","atob","len","length","bytes","i","charCodeAt","blob","Blob","type","rawAudioProcessor","URL","createObjectURL","Input","create","sampleRate","context","inputStream","supportsSampleRateConstraint","navigator","mediaDevices","getSupportedConstraints","AudioContext","analyser","createAnalyser","audioWorklet","addModule","getUserMedia","audio","ideal","echoCancellation","source","createMediaStreamSource","worklet","AudioWorkletNode","connect","error","_inputStream","_context","getTracks","forEach","track","stop","close","constructor","this","audioConcatProcessor","Output","gain","createGain","destination","isValidSocketEvent","event","Connection","config","socket","_ref","_ref2","origin","process","env","ELEVENLABS_CONVAI_SERVER_ORIGIN","pathname","ELEVENLABS_CONVAI_SERVER_PATHNAME","WebSocket","signedUrl","agentId","conversationConfig","Promise","resolve","reject","addEventListener","message","JSON","parse","data","conversation_initiation_metadata_event","console","warn","once","conversationId","conversation_id","parseInt","agent_output_audio_format","replace","_socket","defaultCallbacks","onConnect","onDisconnect","onError","onDebug","onMessage","onStatusChange","onModeChange","Conversation","startSession","options","fullOptions","_extends","status","input","connection","output","_connection","_input","_output","_this","lastInterruptTimestamp","mode","inputFrequencyData","outputFrequencyData","volume","endSession","async","updateStatus","updateMode","onEvent","parsedEvent","interruption_event","event_id","fadeOutAudio","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","audio_event","addAudioBase64Chunk","audio_base_64","send","stringify","ping_event","_unused","onInputWorkletMessage","audioMessage","user_audio_chunk","onOutputWorkletMessage","finished","chunk","value","port","postMessage","exponentialRampToValueAtTime","currentTime","setTimeout","calculateVolume","frequencyData","getId","setVolume","getInputByteFrequencyData","frequencyBinCount","getByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","onmessage"],"mappings":"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"}